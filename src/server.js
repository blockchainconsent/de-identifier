/*
 *
 *
 * (c) Copyright Merative US L.P. and others 2020-2022 
 *
 * SPDX-Licence-Identifier: Apache 2.0
 *
 */

require('newrelic');
require('dotenv').config();

const log4js = require('log4js');
const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');
const express = require('express');
const swaggerUI = require('swagger-ui-express');
const health = require('@cloudnative/health-connect');

const swaggerDoc = require('./swagger.json');

const config = require('./config/config');
const { getTenantIDs } = require('./api/helpers/keyprotect-helper');

const deIdentifierRoute = require('./api/routes/de-identifier');
const identifierRoute = require('./api/routes/identifier');
const log = require('./api/helpers/logger').getLogger('app');
const { registerChecks } = require('./api/helpers/healthChecker');
const CloudantHelper = require('./db/DeIdentifierStore');
const { getDBNameByTenantID } = require('./api/helpers/db');

const app = express();

// Configure express
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.disable('x-powered-by');

// Set up requests logging
const requestLog = require('./api/helpers/logger').getLogger('request');

requestLog.level = 'error';
app.use(log4js.connectLogger(requestLog, { level: log4js.levels.DEBUG }));

// Initiate database connection
const initDBConnection = async () => {
  try {
    const cloudantClient = CloudantHelper.getInstance();
    await cloudantClient.setupCloudant();
    await cloudantClient.checkConnection();

    // get or create the DB by tenantID
    const tenantIDs = await getTenantIDs();
    // eslint-disable-next-line no-restricted-syntax
    for (const tenantID of tenantIDs) {
      const dbName = getDBNameByTenantID(tenantID);
      // eslint-disable-next-line no-await-in-loop
      await cloudantClient.getOrCreateDB(dbName);
    }
  } catch (err) {
    const errMsg = `Error starting server. Failed to setup Cloudant: ${err}`;
    log.error(errMsg);
  }
};

// Configure routes
app.use('/api/de-identifier', deIdentifierRoute);
app.use('/api/identifier', identifierRoute);

const healthcheck = new health.HealthChecker();
app.use('/de-identifier/health', health.HealthEndpoint(healthcheck));
app.use('/de-identifier/live', health.LivenessEndpoint(healthcheck));
app.use('/ready', health.ReadinessEndpoint(healthcheck));

// Configure Swagger
app.use('/de-identifier', swaggerUI.serve, swaggerUI.setup(swaggerDoc));

app.use((req, res) => {
  res.status(404).json({
    status: 404,
    message: 'Not Found',
  });
});

// eslint-disable-next-line no-unused-vars
app.use((err, req, res) => {
  log.error(err);

  const status = err.statusCode || 500;
  res.status(status).json({
    status,
    message: err.message,
  });
});

log.info('Starting server');

/*
 * To launch HTTPS server it requires
 * private key (tls.key) and certificate (tls.crt).
 * For test and local development these files can be generated by openssl tool.
 *
 * openssl genrsa -out key.pem
 * openssl req -new -key key.pem -out csr.pem
 * openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem
 * rm csr.pem
 *
 * openssl genrsa -des3 -out server.key 1024
 * openssl req -new -key server.key -out server.csr
 * cp server.key server.key.org
 * openssl rsa -in server.key.org -out tls.key
 * openssl x509 -req -days 3650 -in server.csr -signkey tls.key -out tls.crt
 * rm -rf server.key.org
 * rm -rf server.csr
 */
let server;
let msg;
if (config.httpsEnabled) {
  log.info('HTTPS enabled');

  const keyfile = path.join(__dirname, 'ssl', 'tls.key');
  const certFile = path.join(__dirname, 'ssl', 'tls.crt');

  const httpsOptions = {
    key: fs.readFileSync(keyfile),
    cert: fs.readFileSync(certFile),
  };

  msg = `HTTPS server started on port ${config.port}`;
  server = https.createServer(httpsOptions, app);
} else {
  msg = `Server up on port ${config.port}`;
  server = http.createServer(app);
}
server.listen(config.port, () => {
  log.info(msg);
  initDBConnection();
  registerChecks(health, healthcheck);
});

// Handle shutdown signals. Safely shutting down processes and closing connections
const signalTraps = ['SIGTERM', 'SIGINT', 'SIGUSR2'];
signalTraps.forEach((type) => {
  process.once(type, () => {
    log.info(`Received kill '${type}' signal, shutting down gracefully`);
    server.close((err) => {
      if (err) {
        log.error('An error while shutting down:', err);
        // eslint-disable-next-line no-process-exit
        process.exit(1);
      }
      // eslint-disable-next-line no-process-exit
      process.exit(0);
    });
  });
});

module.exports = server;
